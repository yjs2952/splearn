## 26강 회원 애플리케이션 서비스 구현
### 어떤 단위로 기능을 분리할 것인가 하는 기준을 세운것이 provided interface
- 어떤 의도를 가지고 외부에 이 애플리케이션을 구분해 놓았는지 나누는 기준
- 따라서 서비스 빈에 '인터페이스 구현이 하나인데 굳이 인터페이스 만들어야 하냐요?' 라는 말은 헥사고널에서는 하지 말자
- 계층형 아키텍처에서 한 계층이 다른 계층을 사용할 때는 인터페이스를 통해 접근한다

## 27강 회원 애플리케이션 서비스 테스트(1)
### 클린 코드를 하고 싶으면 테스트 코드를 반드시 만들어야 한다
- 헥사고널도 마찬가지이다

## 28강 회원 애플리케이션 서비스 테스트(2)

### 테스트 코드에서 의존성 주입하는 다양한 방법
- @Autowired 사용
- 생성자로 바로 주입
    1. @TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL) 어노테이션 사용
        - 자바의 경우 record 타입 사용 가능 (스프링부트 3.2 이상)
        - 코틀린의 경우 primary constructor로 바로 받으면 됨
    2. spring.test.constructor.autowire.mode=all 설정
        - [junit-platform.properties](src/test/resources/junit-platform.properties)

### 통합 테스트 시 주의할 점

- 테스트 코드 간 영향을 주면 안된다
    - 이전 테스트 코드에서 생성한 엔티티가 다음 테스트 결과에 영향을 주는 경우
    - @Transactional 어노테이션을 사용하여 트랜잭션을 롤백 처리할 수 있음

## 29강 표준 유효성 검사 도구를 이용한 요청 데이터 검증

### 어떤 계층에서 검증을 해야하는가

- 이전 계층에서 검증을 완료했다고 신뢰할 수 있는가
- 애플리케이션 레이어가 중요한 방어막이 되어야 한다
- JSR-303 유효성 검사 도구를 사용하여 요청 데이터 검증
    - spring-boot-starter-validation 의존성 추가
    - @Validated 를 사용하여 파라미터에 설정된 정보를 참고하여 유효성 검증을 먼저 수하는 코드를 자동 삽입
        - 유효성 검증을 수행하려는 대상에 @Valid 어노테이션을 사용해야함
        - 코틀린에서는 @field: 를 붙여야 validation 이 동작함
            - 코틀린은 primary 생성자 필드에 어노테이션을 붙이면 기본적으로 생성자 파라미터에 어노테이션이 붙음
            - spring-validation 은 생성자가 아닌 필드에 어노테이션을 붙여야 적용됨

## 30강 회원 애플리케이션 기능 추가

### spring data jpa 를 사용할 때는 업데이트 할 때에도 ~repository.save() 메서드를 사용한다

- jpa 의 경우 persist(), merge() 밖에 없기 때문에 save 를 할 수도 할 필요도 없지만
  우리는 spring data jpa 를 사용하기 때문에 spring data 의 방식에 따라 save() 를 사용한다
    - 공식 문제에서도 이렇게 가이드 한다
- 이유는?
    - spring data 는 JPA 만을 위해 만들어진 것이 아니다
        - 다양한 기술의 저장 기술들을 추상화하여 공통된 기능을 모아놓은 repository 를 제공하기 위해 만들어졌다
            - 그래서 spring data jpa 를 사용하더라도 save() 를 사용한다
    - spring data 가 제공하는 기능중에 domain event publication 이 있는데 이 기능을 사용하기 위해서는 save()를 해야한다
    - audit 할 때도 필요함

### 도메인 모델의 핵심 로직은 도메인 모델에 정의하자

- 도메인 모델의 핵심 로직은 도메인 모델에 정의하고 애플리케이션 서비스는 도메인 모델을 조합하는 역할로 한정한다
    - 도메인 모델의 핵심 로직을 어플리케이션 서비스에 노출시키는 것은 지양하자

## 31강 코드 다듬기

- @Fallback
    - 다른 빈을 찾다가 이 타입의 빈이 없으면 이걸 사용해줘 라는 어노테이션
- JUnit 에서는 JUnit 기능을 확장하는 extension 방식을 제공한다
    - standard io extention
        - 표준 입출력에 대한 테스트를 도와주는 확장 기능
        - system.out.println() 메시지도 검증할 수 있다
    - org.junit-pioneer:junit-pioneer:2.3.0 의존성 추가
- Mockito 사용 시 주의할 점
    - 이런 경고 문구가 생기면 mokito 에이전트를 명시적으로 등록해야 경고문구가 안 뜬다
      현재는 mockito 가 스스로 에이전트를 등록해주고 있어 괜찮지만 다른 버전에서는 안될 수도 있다는 경고
        - Mockito is currently self-attaching to enable the inline-mock-maker. This will no longer work in future
          releases of the JDK. Please add Mockito as an agent to your build as described in Mockito's documentation:
    - mockito 의 경우 클래스 파일 컴파일 된 것을 로딩하는 동안 바이트 코드를 실시간으 조작하여 필요한 기능을 삽입한다
        - 다른 클래스가 로딩되는 동안 변환을 시켜 외부로 유출시키거나 외부에서 조작할 수도 있어 동적 에이전트 등록을 금지하도록 하고 있다

-------

## 32강 JPA와 도메인 모델 패턴

### JPA 모델과 도메인 모델의 차이점?

- JPA 모델은 데이터 모델의 일종
- 도메인 모델은 도메인의 개념적인 모델을 실제 구현 코드까지 이어지게 하는 모델?
- 이 둘은 꼭 분리해야 한다?
    - 어댑터 계층에 jpa 엔티티 등 모델을 따로 만든다
    - Repository를 구현한 어댑터를 이용하여 도메인 오브젝트와 jpa 오베젝트를 매핑해준다
- 이런 접근 방식을 선호하는 이유?
    - 데이터 모델과 도메인 모델이 너무 다른 경우
        - 레거시 DB에 도메인 모델 설계를 적용하는 경우
    - 복잡한 도메인 모델이 데이터 모델과 간단히 매핑되지 않는 경우
    - 데이터 저장 기술이 바뀌는 경우

### JPA 기술의 정체성

- ORM: 패러다임이 다른 관계형 DB와 객체지향 모델의 불일치를 해결하는 기술
- JPA 목표는 자바 도메인 모델을 활용할 수 있는 객체/관계 매핑 기능을 제공하는 것

### 스프링 데이터 프로젝트

- 다양한 데이터 저장소에 대한 데이터 접근을 단순하고 일관된 프로그래밍 모델로 제공
- 일관된 프로그래밍 모델: 저장소의 종류와 관계없이 동일한 방식으로 데이터에 접근하도록 한다
- 보일러 플레이트 코드 감소

### 도메인 모델과 JPA 모델을 반드시 분리해야 한다는 주장에 대한 반박

- 대부분 데이터 모델과 도메인 모델이 다르지 않음
- 복잡한 도메인 모델의 매핑은 JPA가 충분히 지원
- 모델 변환 로직과 유사한 두 가지 클래스로 인한 불필요한 복잡성 증가
- JPA는 도매인 계층을 침범하지 않음

## 33강 엔티티 클래스와 JPA 매핑 정보 분리
### 도메인 관심사가 아닌 JPA 어노테이션은 어떻게 제거하지?
- xml 은 annotation 설정을 override 한다
- JPA 어노테이션 설정을 xml 파일로 분리하여 관리
